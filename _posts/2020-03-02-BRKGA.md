---
layout: post
title: An introduction to the BRKGA Algorithm
---

I recently performed a study on a brand new evolutionary algorithm called BRKGA-MP-IPR (what big name, I know). This article aims to explain a little on what the algorithm consists of, its main features and novelties, and some examples of problems it was tested on.

## What does this longs name even means? TL;DR
###### Let's break it into three pieces, so we can get it more easily.
Firstly, BRKGA stands for *Biased random key genetic algorithm*, this is simply a branch of the classical *genetic algorithm* (GA for short). Secondly, MP stands for *Multi parenting* which is just a technique for individuals selection (we'll explain this later on) and finally, IPR stands for *Implicit Path Relink*, a novel version of the *Path relink* local search method, commonly used to enhance solutions found by heuristics by combining them.

## Understanding the core concepts
In order to see the big picture of BRKGA-MP-IPR more clearly, we need to understand the core concepts the algorithm relies on, and these are:
- Genetic Algorithm;
- Biased Random Keys;
- Multi Parenting;
- Path Relink;

## 1. Genetic Algorithm
Genetic algorithms (GAs) are a family of metaheuristics deeply inspired by the theory of natural evolution. GAs are implemented so they reflect various processes of natural selection such as the survival of the fittest individuals, breeding, mutation and of course the evolution of individuals. Common usages of GAs include global optimization and scheduling problems, even though since its initial development numerous variations of GAs were crafted to fit a very wide field of real-world problems ([see the list here](https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications)).

In terms of code, the simplest versions of GAs are simple to understand. I'm linking here [the most relevant implementations listed by Github](https://github.com/search?l=Python&q=simple+genetic+algorithm&type=Repositories) if you want to explore how it looks in real code.

## 2. Biased Random Keys
To represent a candidate solution for a problem, a GA encodes a solution in the form of an individual. The simplest example of this might be a population of individuals that can be decoded to solutions for a TSP ([Traveling Salesperson Problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem)) instance. Below there's an exampĺe of such a representation:

### 2.1. Simple enconding
```python
# a possible solution as a list of numbers
print(population[individual_index])
# output: [1,2,3,4,5]
```
In this example, the variable *individual* stores the order in which cities are visited on the salesperson tour, and like this, each number is a graph edge.

### 2.2. Random Key enconding
Generally, a *random key* is a float in the interval *[0,1]*. Random keys will represent the information seen in the example above in a similar manner but with some adtional perks: We now won't have to worry about possibly generating invalid new individuals while breeding or mutating (say a mutated gene points to a inexistent city on the TSP instance) and we'll represent individuals in a problem independent manner (permutation problems in general are simply represented by random keys). Here's the same example code from above, now using a random key scheme:

```python
# a possible solution as a list of random keys 
print(population[some_individual_index])
# output: [0.54,0.89,0.32,0.11,0.73]

# decode the individual to a real solution
print(decode(population[some_individual_index]))
# output: [3,2,0,4,1]
```
We can notice that indenpendently of what genes were generated during breeding and mutation all solutions are valid (given that a decoding will be performed on the individual). 

Now one last thing about random keys is how a decoder method will translate a list of random keys to a feasible solution. It can be quite simple actually, in the decodification scheme above we just sorted the alleles in ascending order (the ordered array is *[0.11,0.32,0.54,0.73,0.89]* ) and mapped the ordered keys with their original index in the list (so we get solution *[3,2,0,4,1]* ). There are others methods of decoding solutions, this is just the simplest one.

If you're looking for more information, please refer to the original publication by [Bean (1994)](add url)

### 2.3. Biased Random Key
This variation of genetic algorithms is proposed as two changes in the breeding method: 
- One of the parents chosen for mating is biased to be of higher fitness than the other parent. A strategy to always have a biased couple of individuals is to select one of them from the elite group (a smaller portion of the population that contains the individuals with the current best fitnesses).
- The probability that an off-spring inherits the allele of its elite parent is higher than from its non-elite parent.
The empirical intuition of this algorithmitic choice is that a elite-biased offspring will elevate the overall quality of the population and consequently leading to a better performance of the evolutional process. 

{% include image.html 
   url="/images/posts/brkga/brkga_flowchart.png" 
   description="Flowchart of a BRKGA"
   source="J.F. Gonçalves, M.G.C. Resende"
%}


## 3.Multiparenting
## 4. Implicit Path-Relinking
## 5. Examples of usage
## 6. Conclusion

## Implementation by C. E. Andrade
For clarification, I highly recommend that you go check the incrdible python [implementation of BRKGA-MP-IPR](github.com/ceandrade/brkga_mp_ipr_python) developed by [Carlos Andrade](https://ceandrade.github.io/). It contains excellent code, documentation and walkthroughs.

## Acknowledgments
## References